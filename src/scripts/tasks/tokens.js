const _ = require('lodash');
const gulp = require('gulp');
const gutil = require('gulp-util');
const Path = require('path');
const fs = require('fs');
const ase = require('ase-utils');
const rename = require('gulp-rename');
const Color = require('color');
const transform = require('vinyl-transform');
const map = require('map-stream');
const concat = require('gulp-concat');
const crypto = require('crypto');

const tokenUtils = require('../../tokens/tokenUtils');
const config = require('../../config');

function makeContext(arr) {
    const obj = {};
    arr.forEach((item) => {
        _.forOwn(item, (val, key) => {
            obj[key] = val;
        });
    });
    return obj;
}

/**
 * Generates the Sass tokens (variables) from design tokens.
 * Inserts a hash of the tokens in the file's header, and disables
 * most linters on the file.
 * https://github.com/sasstools/sass-lint
 * https://github.com/brigade/scss-lint
 * https://stylelint.io/user-guide/configuration/
 * @param {string} tokens
 */
const getSassTokens = tokens => `
// Design System Tokens.
// ${crypto.createHash('md5').update(tokens).digest('hex')}.
// This file is automatically generated, do not change it manually.
//
// sass-lint:disable-all
// scss-lint:disable all
/* stylelint-disable */

${tokens}
`;

gulp.task('tokens:css', () => {
    function formatAliases(tokens, filename) {
        const prefix = filename.match(/aliases/) ? 'color' : null;
        const doc = _.map(tokens, (val, key) => tokenUtils.makeCSSVariable(prefix, key, val));

        return doc.join('\n');
    }

    function formatTokens(tokens, filename) {
        const category = _.kebabCase(tokens.global.category);
        let context;

        if (tokens.imports) {
            const imports = tokens.imports.map((file) => {
                const path = Path.join(Path.dirname(filename), file);
                return JSON.parse(fs.readFileSync(path));
            });
            context = makeContext(imports);
        }

        const doc = _.map(tokens.props, (val, key) => {
            let textValue = val;

            if (typeof val.value !== 'undefined') {
                textValue = val.value;
            }

            const compiled = _.template(textValue);
            textValue = compiled(context);

            // Deal with string types
            if (tokens.global.format === 'string') {
                textValue = tokenUtils.quote(textValue);
            }

            return tokenUtils.makeCSSVariable(category, key, textValue);
        });

        return doc.join('\n');
    }

    const cssify = transform((filename) => {
        return map((chunk, next) => {
            const tokens = JSON.parse(chunk.toString());
            const format = tokens.global ? formatTokens : formatAliases;

            return next(null, format(tokens, filename));
        });
    });

    const template = transform(() => {
        return map((chunk, next) => {
            return next(null, getSassTokens(chunk.toString()));
        });
    });

    return gulp
        .src([config.paths.ui.aliases, Path.join(config.paths.ui.tokens, '*.json')])
        .pipe(cssify)
        .pipe(concat(config.swatches.scss))
        .pipe(template)
        .pipe(gulp.dest(config.paths.ui.scss))
        .on('error', (err) => {
            gutil.log(err.message);
        })
        .on('end', () => {
            gutil.log(`Built ${config.swatches.scss} in ${config.paths.ui.scss}`);
        });
});

gulp.task('tokens:sketch', () => {
    function getColors(data) {
        const arr = [];

        // eslint-disable-next-line
        for (const key in data) {
            const val = data[key];
            const color = Color(val);
            arr.push(color.rgbString());
        }

        return arr;
    }

    const sketchify = transform(() => {
        return map((chunk, next) => {
            const data = JSON.parse(chunk.toString());
            const formatted = {
                compatibleVersion: '1.0',
                pluginVersion: '1.1',
                colors: getColors(data),
            };
            return next(null, JSON.stringify(formatted, null, 4));
        });
    });

    return gulp
        .src([config.paths.ui.aliases])
        .pipe(sketchify)
        .pipe(rename(config.swatches.sketch))
        .pipe(gulp.dest(config.paths.ui.swatches))
        .on('error', (err) => {
            gutil.log(err.message);
        })
        .on('end', () => {
            gutil.log(`Built ${config.swatches.sketch} in ${config.paths.ui.swatches}`);
        });
});

gulp.task('tokens:adobe', () => {
    const VERSION_NUMBER = '1.0.0';

    function formatAdobeFloatColour(val) {
        if (val.match(/transparent/)) {
            return [0, 0, 0];
        }

        const color = Color(val);
        const arr = color.rgbArray();

        return [arr[0] / 255, arr[1] / 255, arr[2] / 255];
    }

    function generateColours(data) {
        const arr = [];

        // eslint-disable-next-line
        for (const key in data) {
            const val = data[key];
            const colour = formatAdobeFloatColour(val);

            arr.push({
                name: _.startCase(_.lowerCase(key)),
                model: 'RGB',
                color: colour,
                type: 'global',
            });
        }

        return arr;
    }

    const swatchify = transform(() => {
        return map((chunk, next) => {
            const data = JSON.parse(chunk);
            const input = {
                version: VERSION_NUMBER,
                groups: [],
                colors: generateColours(data),
            };
            return next(null, ase.encode(input));
        });
    });

    return gulp
        .src([config.paths.ui.aliases])
        .pipe(swatchify)
        .pipe(rename(config.swatches.adobe))
        .pipe(gulp.dest(config.paths.ui.swatches))
        .on('error', (err) => {
            gutil.log(err.message);
        })
        .on('end', () => {
            gutil.log(`Built ${config.swatches.adobe} in ${config.paths.ui.swatches}`);
        });
});

gulp.task('tokens', [
    'tokens:sketch',
    'tokens:adobe',
    'tokens:css',
]);
